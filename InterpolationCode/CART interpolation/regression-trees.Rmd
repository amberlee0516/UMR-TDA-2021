---
title: "LRTM_CART"
author: "Alaina Stockdill"
data: "07/1/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Import libraries
```{r}
library(tidyverse)
library(lubridate)
library(stringr)
library(caret)
library(rattle)
library(rpart)
library(kableExtra)
library(dplyr)
```

# Predicting missing values in the LTRM data with regression trees

In order to get the LTRM data ready to use TDAmapper, we need to interpolate the missing values. While many methods have been considered, including linear/polynomial/multivariate regressions and inverse distance interpolation, we will also explore interpolation using regression trees. The benefit of the CART regression tree is that they will automatically choose the most important variables in predicting the target variables and are able to handle missing data very easily. With a data set that contains a large amount of incomplete rows, it seems that this method will be helpful in getting around this issue.

The data set that we are using has been cleaned to:

  1. Replace values with bad QF codes with NA
  2. Replace negative values for TP, TN, SS, TEMP, and with the minimum recorded value
  3. Replace engative WDP values with 0
  4. Filtered for surface samples (excluded mid and bottom samples)
  5. Filtered for random samples (excluded fixed sites in river tributaries)
  6. Combined rows that had the sample SHEETBAR values

```{r}
setwd("/Users/alainastockdill/UMR-TDA-2021/InterpolationCode/CART interpolation")
water <- read.csv(file = "../../LTRM data/water_data_qfneg.csv")

```

```{r}
# Add in the date, year, and season
water <- water %>% 
  mutate(nice_date = mdy(DATE),
         year = year(nice_date),
         season = quarter(nice_date, fiscal_start = 3)) %>%
  select(-SHEETBAR, -nice_date, -DATE, -LOCATCD)

# Make the FLDNUM and STRATUM categorical variables
water$FLDNUM <- as.character(water$FLDNUM)
water$STRATUM <- as.character(water$STRATUM)
water$season <- as.character(water$season)

water_vars <- list("TP", "TN", "TURB", "COND", "VEL", "WDP", "SECCHI", "CHLcal", "SS", "TEMP", "DO")

predictor_vars <- c("TP", "TN", "TURB", "COND", "VEL", "WDP", "season", "STRATUM", "FLDNUM", "CHLcal", "SS", "TEMP", "SECCHI", "DO", "year")

model_data <- water[predictor_vars]

```
## TN
```{r}
### COMPLETE TN COLUMN ###
# Create a new data set that removes only the na TN values
water_TN = model_data %>%
  filter_at(vars(TN), any_vars(!is.na(.)))


sample_size = 0.80 * nrow(water_TN)
set.seed(571)
train_indices <- sample(seq_len(nrow(water_TN)), size = sample_size)

data_train <- water_TN[train_indices, ]
data_test <- water_TN[-train_indices, ]

set.seed(4321)
model_controls <- rpart.control(max_depth = 20)
tr.TN_rpart <- rpart(TN ~ .,
                    data = data_train,
                    method = "anova",
                    control = model_controls )
fancyRpartPlot(tr.TN_rpart, main = "TN prediction for all years")

data_test$PREDICTED_TN <- predict(tr.TN_rpart, data_test)
summary <- summary(data_test$TN)
pred_summary <- summary(data_test$PREDICTED_TN)

TN_sum <- c(summary[1], summary[2], summary[3], summary[4], summary[5], summary[6])
TN_pred_sum <-c(pred_summary[1], pred_summary[2], pred_summary[3], pred_summary[4], pred_summary[5], pred_summary[6])

TN_sum2 <- list(unname(summary(data_test$TN)))
TN_pred_sum2 <- list(unname(summary(data_test$PREDICTED_TN)))

model_summary <- data.frame(TN_sum, TN_pred_sum)
model_summary2 <- data.frame(TN_sum2, TN_pred_sum2)

TN <- c(MAE(data_test$TN, data_test$PREDICTED), RMSE(data_test$TN, data_test$PREDICTED), mean((data_test$TN - data_test$PREDICTED)^2))

```
## functions take 3
```{r}
rmna <- function(target, df) {
  data <- df %>% filter_at(vars(target), any_vars(!is.na(.)))
  return(data)
}

get_train <- function(df) {
  sample_size = 0.80 * nrow(df)
  set.seed(571)
  train_indices <- sample(seq_len(nrow(df)), size = sample_size)
  
  return(train_indices)
  
}

make_trees <-function(target, df) {
  print(target)
  
  #predictors <- names(df[!target])
  #https://stackoverflow.com/questions/7500219/reading-rpart-input-parameters-from-a-text-variable
  model_formula <- as.formula(paste(target, " ~ ."))
  
  model_controls <- rpart.control(max_depth = 20)
  tr_rpart <- rpart(model_formula,
                      data = df,
                      method = "anova",
                      control = model_controls )
  title = paste(target, " prediction for all years")
  tree <- fancyRpartPlot(tr_rpart, main = title)
  #ggsave(tree)
  
  return(tr_rpart)
  
}

get_stats <- function(df, target, errorBool) {
  if(errorBool == TRUE) {
    errors <- c(MAE(df$target, df$PREDICTED), RMSE(df$target, df$PREDICTED))
    return(errors)
    
  } else {
    
    tar_sum <- summary(df$target)
    pred_sum <- summary(df$PREDICTED)
    
    var_sum <- c(tar_sum[1], tar_sum[2], tar_sum[3], tar_sum[4], tar_sum[5], tar_sum[6])
    var_pred_sum <-c(pred_sum[1], pred_sum[2], pred_sum[3], pred_sum[4], pred_sum[5], pred_sum[6])

    model_summary <- data.frame(var_sum, var_pred_sum)
    
    return(model_summary)
    
  }
    
  ## ADD PLOTS
  
}



rpart_model  <- function(target, df) {
  water_data <- rmna(target, df)
  
  indices <- get_train(df)
  
  data_train <- water_data[indices, ]
  data_test <- water_data[-indices, ]
  
  model <- make_trees(target, data_train)
  
  data_test$PREDICTED <-  predict(model, data_test)
  #model_summary <- get_stats(water_data, FALSE)
  #model_errors <-get_stats(water_data, TRUE)
  
  return(water_data$PREDICTED)
  
  
}



```

```{r}
trees <- lapply(water_vars, rpart_model, water)

```

## Functions take 2
```{r}
# Make new data frame with complete target variable column
makeCompCol <- function(target, water_data) {
  data <- water_data %>% filter_at(vars(!!sym(target), any_vars(!is.na(.))))
  return(data)
}


test_model <- function(target, model, water_data, water_test) {
  water_test$PREDICTED <- predict(model, water_test)
  summary <- summary(water_test[!!sym(target)])
  pred_summary <- summary(data_test$PREDICTED)
  
  return 
  
  TN_sum <- c(summary[1], summary[2], summary[3], summary[4], summary[5], summary[6])
  TN_pred_sum <-c(pred_summary[1], pred_summary[2], pred_summary[3], pred_summary[4], pred_summary[5], pred_summary[6])
  
  model_summary <- data.frame(TN_sum, TN_pred_sum)
  
  
  TN <- c(MAE(data_test$TN, data_test$PREDICTED), RMSE(data_test$TN, data_test$PREDICTED), mean((data_test$TN - data_test$PREDICTED)^2))
    
}


make_models <- function(target, water_data) {
  
  sample_size = 0.80 * nrow(water_data)
  set.seed(571)
  train_indices <- sample(seq_len(nrow(water_data)), size = sample_size)
  
  data_train <- water_data[train_indices, ]
  data_test <- water_data[-train_indices, ]
  
  set.seed(4321)
  model_controls <- rpart.control(max_depth = 20)
  tr_rpart <- rpart(!!sym(target) ~ .,
                      data = data_train,
                      method = "anova",
                      control = model_controls )
  #title = paste(target, " prediction for all years")
  #fancyRpartPlot(tr_rpart, main = title)
  
  data_test$PREDICTED <- predict(model, data_test)
  summary <- summary(data_test[!!sym(target)])
  pred_summary <- summary(data_test$PREDICTED)
  
   TN_sum <- c(summary[1], summary[2], summary[3], summary[4], summary[5], summary[6])
  TN_pred_sum <-c(pred_summary[1], pred_summary[2], pred_summary[3], pred_summary[4], pred_summary[5], pred_summary[6])
  
  model_summary <- data.frame(TN_sum, TN_pred_sum)
  
  
  TN <- c(MAE(data_test$TN, data_test$PREDICTED), RMSE(data_test$TN, data_test$PREDICTED), mean((data_test$TN - data_test$PREDICTED)^2))
}


```




## TP
```{r}
### COMPLETE TP COLUMN ###
# Create a new data set that removes only the na TN values
water_TP = model_data %>%
  filter_at(vars(TP), any_vars(!is.na(.)))


sample_size = 0.80 * nrow(water_TP)
set.seed(571)
train_indices <- sample(seq_len(nrow(water_TP)), size = sample_size)

data_train <- water_TP[train_indices, ]
data_test <- water_TP[-train_indices, ]

set.seed(4321)
model_controls <- rpart.control(max_depth = 20)
tr.TP_rpart <- rpart(TP ~ .,
                    data = data_train,
                    method = "anova",
                    control = model_controls )
fancyRpartPlot(tr.TP_rpart, main = "TP prediction for all years")

data_test$PREDICTED_TP <- predict(tr.TP_rpart, data_test)
summary <- summary(data_test$TP)
pred_summary <- summary(data_test$PREDICTED_TP)

TP_sum <- c(summary[1], summary[2], summary[3], summary[4], summary[5], summary[6])
TP_pred_sum <-c(pred_summary[1], pred_summary[2], pred_summary[3], pred_summary[4], pred_summary[5], pred_summary[6])

TP_model_summary <- data.frame(TP_sum, TP_pred_sum)

model_summary<- rbind(model_summary, TP_model_summary)

TP <- c(MAE(data_test$TP, data_test$PREDICTED_TP), RMSE(data_test$TP, data_test$PREDICTED_TP), mean((data_test$TP - data_test$PREDICTED_TP)^2))

```









# FUNCTIONS take 1
```{r}
# Make new data frame with complete target variable column
makeCompCol <- function(target, water_data) {
  data <- water_data %>% filter_at(vars(!!sym(target), any_vars(!is.na(.))))
  return(data)
}

model_stats <- function(model, water_data, data_test, target){
  
  data_test$PREDICTED <- predict(model, data_test)
  summary <- summary(data_test$target)
  pred_summary <- summary(data_test$PREDICTED_TP)
  
  TP_sum <- c(summary[1], summary[2], summary[3], summary[4], summary[5], summary[6])
  TP_pred_sum <-c(pred_summary[1], pred_summary[2], pred_summary[3], pred_summary[4], pred_summary[5], pred_summary[6])
  
  TP_model_summary <- data.frame(TP_sum, TP_pred_sum)
  
  model_summary<- rbind(model_summary, TP_model_summary)
  
  TP <- c(MAE(data_test$TP, data_test$PREDICTED_TP), RMSE(data_test$TP, data_test$PREDICTED_TP), mean((data_test$TP - data_test$PREDICTED_TP)^2))
  
  
  
}


# Make a model for each of the dataframes with a complete target column
make_models <- function(target, water_data) {
  sample_size = 0.80 * nrow(water_data)
  set.seed(571)
  train_indices <- sample(seq_len(nrow(water_data)), size = sample_size)
  
  data_train <- water_data[train_indices, ]
  data_test <- water_data[-train_indices, ]
  
  model_controls = rpart.control(cp = .01)
  tr.rpart <- rpart( target ~ .,
                    data = water_data,
                    method = "anova",
                    control = model_controls)
  
  data_test$PREDICTED <- predict(tr.TN_rpart, data_test)
  
  model_sum <- summary(data_test[!!sym(target), "PREDICTED"])
  
  mae <- MAE(data_test$TN, data_test$PREDICTED)
  rmse <- RMSE(data_test$TN, data_test$PREDICTED)
  mse <- mean((data_test$TN - data_test$PREDICTED)^2)
  
  return(list(model_sum, mae, rmse, mse))
  
}




```

```{r}
model_dfs <- lapply(water_vars, makeCompCol, model_data)
tree_models <- lapply(water_vars, make_models, model_data)

# Print the trees
lapply(1:4, function(x) fancyRpartPlot(tree_models[[x]],
                                               main = paste(as.character(x)) ))

```

```{r}

sample_size = 0.80 * nrow(water_TN)
set.seed(571)
train_indices <- sample(seq_len(nrow(water_TN)), size = sample_size)

data_train <- comp_TN_data[train_indices, ]
data_test <- comp_TN_data[-train_indices, ]

set.seed(4321)
tr.TN_rpart1 <- rpart(TN ~ .,
                    data = data_train,
                    method = "anova",
                    control = (maxdepth = 20))
fancyRpartPlot(tr.TN_rpart, main = "TN prediction for all years")


# Test the model on both the training and testing data
data_train$PREDICTED <- predict(tr.TN_rpart, data_train)
data_test$PREDICTED <- predict(tr.TN_rpart, data_test)

# Plots for actual v. predicted TN values in both the training and testing data
ggplot(data_train, mapping = aes(TN, PREDICTED)) +
  geom_point(alpha = 0.1)

train_lm <- lm(PREDICTED ~ TN, data = data_train)

ggplot(data_test, mapping = aes(TN, PREDICTED)) +
  geom_point(alpha = 0.1)

test_lm <- lm(PREDICTED ~ TN, data = data_test)

# Get the RMSE and correlation coefficient for the test data
print("Mean absolute error: ")
MAE(data_test$TN, data_test$PREDICTED)
print("Root mean square error: ")
RMSE(data_test$TN, data_test$PREDICTED)
print("Mean square error: ")
mean((data_test$TN - data_test$PREDICTED)^2)
#cor(data_test$TN, data_test$PREDICTED)
print("R-square: ")
summary(test_lm)$r.squared
unique(water$FLDNUM)


```







```{r}
### RPART MODEL ###
# Runs on the entire data set - even with na values in all columns
set.seed(84726)
temp_controls = rpart.control(cp = .01)
tr.TN_rpart <- rpart(TN ~ .,
                    data = water,
                    method = "anova",
                    control = temp_controls)
fancyRpartPlot(tr.TN_rpart, main = "TN prediction: cp = .1")
```

```{r}
# Tree evaluation summary 
plotcp(tr.TN_rpart)
printcp(tr.TN_rpart)
rsq.rpart(tr.TN_rpart)
summary(tr.TN_rpart)
```







# Model for all years and seasons combined 

In this model we will only be splitting by the target response variable. A model will be created for each continuous variable using data from all years and seasons. 

```{r}
create_models <- function(target, water_data) {
  # make a subset of the data with a complete target variable column
  temp <- water_data %>% filter(!is.na(target))
  
  model_controls = rpart.control(cp = .01)
  tr.rpart <- rpart(target ~ .,
                    data = temp,
                    method = "anova",
                    control = model_controls)
  return(tr.rpart)
}
```


```{r}

trees_models <- lapply(water_vars, create_models, model_data)

```

```{r}
citation(package = 'rpart')

```
