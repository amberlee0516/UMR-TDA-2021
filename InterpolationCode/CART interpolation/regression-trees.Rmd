---
title: "LRTM_CART"
author: "Alaina Stockdill"
data: "07/1/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Import libraries
```{r}
library(tidyverse)
library(lubridate)
library(stringr)
library(caret)
library(rattle)
library(rpart)
library(kableExtra)
library(dplyr)
```

# Predicting missing values in the LTRM data with regression trees

In order to get the LTRM data ready to use TDAmapper, we need to interpolate the missing values. While many methods have been considered, including linear/polynomial/multivariate regressions and inverse distance interpolation, we will also explore interpolation using regression trees. The benefit of the CART regression tree is that they will automatically choose the most important variables in predicting the target variables and are able to handle missing data very easily. With a data set that contains a large amount of incomplete rows, it seems that this method will be helpful in getting around this issue.

The data set that we are using has been cleaned to:

  1. Replace values with bad QF codes with NA
  2. Replace negative values for TP, TN, SS, TEMP, and with the minimum recorded value
  3. Replace engative WDP values with 0
  4. Filtered for surface samples (excluded mid and bottom samples)
  5. Filtered for random samples (excluded fixed sites in river tributaries)
  6. Combined rows that had the sample SHEETBAR values

```{r}
setwd("/Users/alainastockdill/UMR-TDA-2021/InterpolationCode/CART interpolation")
water_data <- read.csv(file = "../../LTRM data/water_data_qfneg.csv")

```

Date and season are added in so that the model can use these values as predictors. Because these variables are included as predictors, we will not need to make separate trees from data that is filtered by these different values. Field number, stratum, and season are all made as categorical variables.

```{r}
# Add in the date, year, and season
water_data <- water_data %>% 
  mutate(nice_date = mdy(DATE),
         year = year(nice_date),
         season = quarter(nice_date, fiscal_start = 3)) %>%
  select(-SHEETBAR, -nice_date, -DATE, -LOCATCD)

# Make the FLDNUM and STRATUM categorical variables
water_data$FLDNUM <- as.character(water_data$FLDNUM)
water_data$STRATUM <- as.character(water_data$STRATUM)
water_data$season <- as.character(water_data$season)

water_vars <- list("TP", "TN", "VEL") #, "TURB", "COND","WDP", "SECCHI", "CHLcal", "SS", "TEMP", "DO")

predictor_vars <- c("TP", "TN", "TURB", "COND", "VEL", "WDP", "season", "STRATUM", "FLDNUM", "CHLcal", "SS", "TEMP", "SECCHI", "DO", "year")

rt_data <- water_data[predictor_vars]

```

## FUNCTIONS
* rmna_row: creates a subset of the entire data set that has a complete column of the variable we   are currently estimating

* get_train_indices: creates a train/test split to test on our model

* make_trees: creates a regression tree to predict a target varible - saves the tree output       (#https://stackoverflow.com/questions/7500219/reading-rpart-input-parameters-from-a-text-variable)

* rt_evalution: takes a target variable with a data and uses the three previous functions to        output a testing data with a predicted column for that variable

* make_plots: makes an actual versus predicted scatter plot and box plots for each actual and       predicted column of the current target variable - will save both plots

* get_model_stats: depending on the errorsBool, this function will either return a list containing   the MAE and RMSE of actual versus predicted values or return a dataframe that contains the        summary stats (Min, Q1, Mean, Q3, Max) for both the actual and predicted column


```{r}
rmna_rows <- function(target_var, df) {
  df <- df %>% filter_at(vars(target_var), any_vars(!is.na(.)))
  return(df)
}

get_train_indices <- function(df) {
  sample_size = 0.80 * nrow(df)
  set.seed(571)
  train_indices <- sample(seq_len(nrow(df)), size = sample_size)
  
  return(train_indices)
  
}

make_trees <-function(target_var, df) {
  
  rpart_formula <- as.formula(paste(target_var, " ~ ."))
  
  model_controls <- rpart.control(cp = .01)
  tr_rpart <- rpart(rpart_formula,
                      data = df,
                      method = "anova",
                      control = model_controls )
  
  tree_title = paste("tree_",target_var, sep = "")
  png_name = paste(tree_title, ".png", sep = "") 
  
  png(png_name)
  tree <- fancyRpartPlot(tr_rpart, main = tree_title)
  dev.off()
  
  return(tr_rpart)
  
}


rt_evaluation  <- function(target_var, df) {
  df <- rmna_rows(target_var, df)
  
  indices <- get_train_indices(df)

  data_train <- df[indices, ]
  data_test <- df[-indices, ]
  
  model <- make_trees(target_var, data_train)
  
  pred_col_name <- paste("PREDICTED_", target_var, sep = "") # New predicted column
  data_test[ , pred_col_name] <-  predict(model, data_test)
  
  #printcp(model)
  
  return(data_test)
}

make_plots <- function(data_test, target_actual, target_pred) {
    X <- data_test[ , target_actual]
    Y <- data_test[ , target_pred]
    
    # scatter plot
    png_name = paste(target_actual, "_predvactual.png", sep = "")
    ggplot(data_test, mapping = aes(x = X, y = Y)) +
      geom_point(alpha = .02) + 
      coord_equal() +
      theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
    ggsave(png_name)
    
    # box plot
    png_name = paste(target_actual, "_boxplot.png", sep = "")
    ggplot(data_test) + 
      geom_boxplot(aes(x = interaction(X,Y)))
    ggsave(png_name)
  
}


get_model_stats <- function(data_test, errorBool) {
  
  data_test <- data.frame(data_test) # make sure data_test is a dataframe
  
  # get the target variable
  target_pred  <- names(select(data_test, contains("PREDICTED_")))  # column name
  target_actual <- sub("PREDICTED_", "", target_pred)
  
  if( errorBool == TRUE )  {
    
    errors <- c( MAE(data_test[ , target_actual], data_test[ , target_pred]), 
                 RMSE(data_test[ , target_actual], data_test[ , target_pred]))
    
    return(errors)
    
  } else {
    
    actual_sum <- summary( data_test[ , target_actual] ) 
    predicted_sum <- summary( data_test[ , target_pred] )
    
    actual <- c(actual_sum[1], actual_sum[2], actual_sum[3],
                 actual_sum[4], actual_sum[5], actual_sum[6])
    
    predicted <-c(predicted_sum[1], predicted_sum[2], predicted_sum[3], 
                     predicted_sum[4], predicted_sum[5], predicted_sum[6])

    model_summary <- data.frame(actual, predicted)
    
    # actual v pred and boxplots 
    make_plots(data_test, target_actual, target_pred)
    
    return(model_summary)
    
  }
}

```

```{r}
water_var_preds <- lapply(water_vars, rt_evaluation, rt_data)
water_var_errors <- lapply( water_var_preds, get_model_stats, TRUE )
water_var_summary <- lapply( water_var_preds, get_model_stats, FALSE )
```


## TN
```{r}
### COMPLETE TN COLUMN ###
# Create a new data set that removes only the na TN values
water_TN = model_data %>%
  filter_at(vars(TN), any_vars(!is.na(.)))


sample_size = 0.80 * nrow(water_TN)
set.seed(571)
train_indices <- sample(seq_len(nrow(water_TN)), size = sample_size)

data_train <- water_TN[train_indices, ]
data_test <- water_TN[-train_indices, ]

set.seed(4321)
model_controls <- rpart.control(max_depth = 20)
tr.TN_rpart <- rpart(TN ~ .,
                    data = data_train,
                    method = "anova",
                    control = model_controls )
fancyRpartPlot(tr.TN_rpart, main = "TN prediction for all years")

data_test$PREDICTED_TN <- predict(tr.TN_rpart, data_test)
summary <- summary(data_test$TN)
pred_summary <- summary(data_test$PREDICTED_TN)

TN_sum <- c(summary[1], summary[2], summary[3], summary[4], summary[5], summary[6])
TN_pred_sum <-c(pred_summary[1], pred_summary[2], pred_summary[3], pred_summary[4], pred_summary[5], pred_summary[6])

TN_sum2 <- list(unname(summary(data_test$TN)))
TN_pred_sum2 <- list(unname(summary(data_test$PREDICTED_TN)))

model_summary <- data.frame(TN_sum, TN_pred_sum)
model_summary2 <- data.frame(TN_sum2, TN_pred_sum2)

TN <- c(MAE(data_test$TN, data_test$PREDICTED), RMSE(data_test$TN, data_test$PREDICTED), mean((data_test$TN - data_test$PREDICTED)^2))

```


## Functions take 2
```{r}
# Make new data frame with complete target variable column
makeCompCol <- function(target, water_data) {
  data <- water_data %>% filter_at(vars(!!sym(target), any_vars(!is.na(.))))
  return(data)
}


test_model <- function(target, model, water_data, water_test) {
  water_test$PREDICTED <- predict(model, water_test)
  summary <- summary(water_test[!!sym(target)])
  pred_summary <- summary(data_test$PREDICTED)
  
  return 
  
  TN_sum <- c(summary[1], summary[2], summary[3], summary[4], summary[5], summary[6])
  TN_pred_sum <-c(pred_summary[1], pred_summary[2], pred_summary[3], pred_summary[4], pred_summary[5], pred_summary[6])
  
  model_summary <- data.frame(TN_sum, TN_pred_sum)
  
  
  TN <- c(MAE(data_test$TN, data_test$PREDICTED), RMSE(data_test$TN, data_test$PREDICTED), mean((data_test$TN - data_test$PREDICTED)^2))
    
}


make_models <- function(target, water_data) {
  
  sample_size = 0.80 * nrow(water_data)
  set.seed(571)
  train_indices <- sample(seq_len(nrow(water_data)), size = sample_size)
  
  data_train <- water_data[train_indices, ]
  data_test <- water_data[-train_indices, ]
  
  set.seed(4321)
  model_controls <- rpart.control(max_depth = 20)
  tr_rpart <- rpart(!!sym(target) ~ .,
                      data = data_train,
                      method = "anova",
                      control = model_controls )
  #title = paste(target, " prediction for all years")
  #fancyRpartPlot(tr_rpart, main = title)
  
  data_test$PREDICTED <- predict(model, data_test)
  summary <- summary(data_test[!!sym(target)])
  pred_summary <- summary(data_test$PREDICTED)
  
   TN_sum <- c(summary[1], summary[2], summary[3], summary[4], summary[5], summary[6])
  TN_pred_sum <-c(pred_summary[1], pred_summary[2], pred_summary[3], pred_summary[4], pred_summary[5], pred_summary[6])
  
  model_summary <- data.frame(TN_sum, TN_pred_sum)
  
  
  TN <- c(MAE(data_test$TN, data_test$PREDICTED), RMSE(data_test$TN, data_test$PREDICTED), mean((data_test$TN - data_test$PREDICTED)^2))
}


```




## TP
```{r}
### COMPLETE TP COLUMN ###
# Create a new data set that removes only the na TN values
water_TP = model_data %>%
  filter_at(vars(TP), any_vars(!is.na(.)))


sample_size = 0.80 * nrow(water_TP)
set.seed(571)
train_indices <- sample(seq_len(nrow(water_TP)), size = sample_size)

data_train <- water_TP[train_indices, ]
data_test <- water_TP[-train_indices, ]

set.seed(4321)
model_controls <- rpart.control(max_depth = 20)
tr.TP_rpart <- rpart(TP ~ .,
                    data = data_train,
                    method = "anova",
                    control = model_controls )
fancyRpartPlot(tr.TP_rpart, main = "TP prediction for all years")

data_test$PREDICTED_TP <- predict(tr.TP_rpart, data_test)
summary <- summary(data_test$TP)
pred_summary <- summary(data_test$PREDICTED_TP)

TP_sum <- c(summary[1], summary[2], summary[3], summary[4], summary[5], summary[6])
TP_pred_sum <-c(pred_summary[1], pred_summary[2], pred_summary[3], pred_summary[4], pred_summary[5], pred_summary[6])

TP_model_summary <- data.frame(TP_sum, TP_pred_sum)

model_summary<- rbind(model_summary, TP_model_summary)

TP <- c(MAE(data_test$TP, data_test$PREDICTED_TP), RMSE(data_test$TP, data_test$PREDICTED_TP), mean((data_test$TP - data_test$PREDICTED_TP)^2))

```









# FUNCTIONS take 1
```{r}
# Make new data frame with complete target variable column
makeCompCol <- function(target, water_data) {
  data <- water_data %>% filter_at(vars(!!sym(target), any_vars(!is.na(.))))
  return(data)
}

model_stats <- function(model, water_data, data_test, target){
  
  data_test$PREDICTED <- predict(model, data_test)
  summary <- summary(data_test$target)
  pred_summary <- summary(data_test$PREDICTED_TP)
  
  TP_sum <- c(summary[1], summary[2], summary[3], summary[4], summary[5], summary[6])
  TP_pred_sum <-c(pred_summary[1], pred_summary[2], pred_summary[3], pred_summary[4], pred_summary[5], pred_summary[6])
  
  TP_model_summary <- data.frame(TP_sum, TP_pred_sum)
  
  model_summary<- rbind(model_summary, TP_model_summary)
  
  TP <- c(MAE(data_test$TP, data_test$PREDICTED_TP), RMSE(data_test$TP, data_test$PREDICTED_TP), mean((data_test$TP - data_test$PREDICTED_TP)^2))
  
  
  
}


# Make a model for each of the dataframes with a complete target column
make_models <- function(target, water_data) {
  sample_size = 0.80 * nrow(water_data)
  set.seed(571)
  train_indices <- sample(seq_len(nrow(water_data)), size = sample_size)
  
  data_train <- water_data[train_indices, ]
  data_test <- water_data[-train_indices, ]
  
  model_controls = rpart.control(cp = .01)
  tr.rpart <- rpart( target ~ .,
                    data = water_data,
                    method = "anova",
                    control = model_controls)
  
  data_test$PREDICTED <- predict(tr.TN_rpart, data_test)
  
  model_sum <- summary(data_test[!!sym(target), "PREDICTED"])
  
  mae <- MAE(data_test$TN, data_test$PREDICTED)
  rmse <- RMSE(data_test$TN, data_test$PREDICTED)
  mse <- mean((data_test$TN - data_test$PREDICTED)^2)
  
  return(list(model_sum, mae, rmse, mse))
  
}




```

```{r}
model_dfs <- lapply(water_vars, makeCompCol, model_data)
tree_models <- lapply(water_vars, make_models, model_data)

# Print the trees
lapply(1:4, function(x) fancyRpartPlot(tree_models[[x]],
                                               main = paste(as.character(x)) ))

```

```{r}

sample_size = 0.80 * nrow(water_TN)
set.seed(571)
train_indices <- sample(seq_len(nrow(water_TN)), size = sample_size)

data_train <- comp_TN_data[train_indices, ]
data_test <- comp_TN_data[-train_indices, ]

set.seed(4321)
tr.TN_rpart1 <- rpart(TN ~ .,
                    data = data_train,
                    method = "anova",
                    control = (maxdepth = 20))
fancyRpartPlot(tr.TN_rpart, main = "TN prediction for all years")


# Test the model on both the training and testing data
data_train$PREDICTED <- predict(tr.TN_rpart, data_train)
data_test$PREDICTED <- predict(tr.TN_rpart, data_test)

# Plots for actual v. predicted TN values in both the training and testing data
ggplot(data_train, mapping = aes(TN, PREDICTED)) +
  geom_point(alpha = 0.1)

train_lm <- lm(PREDICTED ~ TN, data = data_train)

ggplot(data_test, mapping = aes(TN, PREDICTED)) +
  geom_point(alpha = 0.1)

test_lm <- lm(PREDICTED ~ TN, data = data_test)

# Get the RMSE and correlation coefficient for the test data
print("Mean absolute error: ")
MAE(data_test$TN, data_test$PREDICTED)
print("Root mean square error: ")
RMSE(data_test$TN, data_test$PREDICTED)
print("Mean square error: ")
mean((data_test$TN - data_test$PREDICTED)^2)
#cor(data_test$TN, data_test$PREDICTED)
print("R-square: ")
summary(test_lm)$r.squared
unique(water$FLDNUM)


```







```{r}
### RPART MODEL ###
# Runs on the entire data set - even with na values in all columns
set.seed(84726)
temp_controls = rpart.control(cp = .01)
tr.TN_rpart <- rpart(TN ~ .,
                    data = water,
                    method = "anova",
                    control = temp_controls)
fancyRpartPlot(tr.TN_rpart, main = "TN prediction: cp = .1")
```

```{r}
# Tree evaluation summary 
plotcp(tr.TN_rpart)
printcp(tr.TN_rpart)
rsq.rpart(tr.TN_rpart)
summary(tr.TN_rpart)
```







# Model for all years and seasons combined 

In this model we will only be splitting by the target response variable. A model will be created for each continuous variable using data from all years and seasons. 

```{r}
create_models <- function(target, water_data) {
  # make a subset of the data with a complete target variable column
  temp <- water_data %>% filter(!is.na(target))
  
  model_controls = rpart.control(cp = .01)
  tr.rpart <- rpart(target ~ .,
                    data = temp,
                    method = "anova",
                    control = model_controls)
  return(tr.rpart)
}
```


```{r}

trees_models <- lapply(water_vars, create_models, model_data)

```

```{r}
citation(package = 'rpart')

```
