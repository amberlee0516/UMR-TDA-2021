---
title: "ML interpolation"
author: "Amber Lee"
date: "6/22/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

### Load libraries 
```{r}
library(tidyverse)
library(stringr)
library(lubridate)

library(rpart) # for regression tree
library(rpart.plot)
library(caret) # for other models
library(rattle)
library(kableExtra)
library(broom)
```

### Read data

```{r}
water20 <- read.csv("cleaned_data.csv", header = TRUE)
```

### Very brief data exploration

Removed the QF code variable

```{r}

# remove the QF code variables
water20 <- water20 %>% select(all_of(names(water20)
                                     [str_detect(names(water20),
                                                 "QF", negate = T)]))

```

Checked the missingness rate per variable

```{r}
var_missing_rate <- sapply(water20, function(x) sum(is.na(x))/length(x))

var_missing_rate <- data.frame(var = names(var_missing_rate), 
                               missing_rate = unname(var_missing_rate))

var_missing_rate %>% 
  mutate(`missing rate` = round(missing_rate, digits = 3)) %>% 
  select(-missing_rate) %>%
  arrange(-`missing rate`) %>%
  kbl(booktabs = T)
```

```{r}

var_missing_rate %>% filter(missing_rate > 0) %>%
  ggplot(aes(x = var, y = missing_rate)) +
  geom_bar(stat = "identity") +
  coord_flip()

```

Added year and season variables, changed the `FLDNUM` variable to be categorical (character).

** I filtered out observations where `TP` was greater than 2 because that represented .1% of the data **

```{r}

water20 <- water20 %>%
  filter(TP <= 2) %>% # only 70 samples for TP > 2, outlier values screw up model
  mutate(nice_date = mdy(DATE),
         year = year(nice_date),
         quarter = quarter(nice_date, fiscal_start = 3),
         FLDNUM = case_when(FLDNUM == 1 ~ "Lake City, MN", 
                            FLDNUM == 2 ~ "Onalaska, WI",
                            FLDNUM == 3 ~ "Bellevue, IA",
                            FLDNUM == 4 ~ "Brighton, IL",
                            FLDNUM == 5 ~ "Jackson, MO",
                            FLDNUM == 6 ~ "Havana, IL"),
         FLDNUM = as.factor(FLDNUM),
         STRATUM = as.factor(STRATUM)) %>% # CART can split on categorical variable if
                                         # encoded as a factor variable
  select(-SHEETBAR, -nice_date, -DATE, -LOCATCD) 

```

### Notes

* regression (what are the steps for it?)

* classification and regression trees (CART)

* neural networks

* support vector machines

### predicting TP with entire dataset

# 80/20 

```{r}
set.seed(4747)

# train and test data created from rows with existing TP values
fullTP <- water20 %>% filter(!is.na(TP))

# this gives me a total of ten 80/20 splits
train_idx <- createDataPartition(fullTP$TP, p = .8,
                                 list = FALSE, times = 10)

watertrain1 <- fullTP[train_idx[,1],]
watertest1 <- fullTP[-train_idx[,1],]


```

There are:

* 105,000 samples in the filtered water dataset `water20`

* 59,000 samples in the training data `fullTP`. This is because the testing and training data both need existing `TP` values

* 47,000 samples in the `watertrain1`

* and 11,800 samples in the `watertest1`

### using the `rpart` library

https://www.statmethods.net/advstats/cart.html 

```{r}

tr.TP <- rpart(TP ~ .,
               data = watertrain1,
               control = rpart.control(xval = 15,
                                       minsplit = 100)) 

printcp(tr.TP)

png("tree_TP.png")
fancyRpartPlot(tr.TP)
dev.off()

png("tree_TP_CV.png")
plotcp(tr.TP)
dev.off()

```
```{r}
summary(tr.TP)
# tidy(tr.TP) TODO
```

https://rstudio-pubs-static.s3.amazonaws.com/27179_e64f0de316fc4f169d6ca300f18ee2aa.html

```{r}
# Prediction error rate in training data = Root node error * rel error * 100%
# Prediction error rate in cross-validation = Root node error * xerror * 100%
# Hence we want the cp value (with a simpler tree) that minimizes the xerror. 

# 

bestcp <- tr.TP$cptable[which.min(tr.TP$cptable[,"xerror"]),"CP"]
bestcp

tr.TP.prune <- prune(tr.TP, cp = bestcp)

data.frame(round(tr.TP.prune$cptable, digits = 3)) %>%
  kbl(booktabs = T)

```


https://datascience.stackexchange.com/questions/31346/caret-and-rpart-does-caret-automatically-prune-rpart-trees

http://www.rdatamining.com/docs/regression-and-classification-with-r

### Model evaluation

```{r}

watertrain1$TP.PREDICT <- predict(tr.TP, data = watertrain1)

watertrain1 <- watertrain1 %>%
  mutate(TP.SQ.ERROR = (TP - TP.PREDICT)^2)

print("RSME is")
sqrt(sum(watertrain1$TP.SQ.ERROR)/dim(watertrain1)[1])

watertrain1 %>% 
  ggplot(aes(x = TP, y = TP.PREDICT)) +
  geom_point(alpha = 0.2) +
  coord_equal() +
  theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)

ggsave("tree_training_predictvsactual.png")

```

```{r}
watertest1$TP.PREDICT <- predict(tr.TP.prune, watertest1)
  
watertest1 <- watertest1 %>%
  mutate(TP.SQ.ERROR = (TP - TP.PREDICT)^2)

print("RSME is")
sqrt(sum(watertest1$TP.SQ.ERROR)/dim(watertest1)[1])

watertest1 %>% 
  ggplot(aes(x = TP, y = TP.PREDICT)) +
  geom_point(alpha = 0.2) +
  coord_equal() +
  theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)

ggsave("tree_test_predictvsactual.png")

```


#### multivariate linear regression

```{r}

watertrain2 <- fullTP[train_idx[,2],]
watertest2 <- fullTP[-train_idx[,2],]

# remove all na's because that's how GLM works
watertrain2 <- watertrain2 %>%
  filter_all(all_vars(!is.na(.)))
watertest2 <- watertest2 %>%
  filter_all(all_vars(!is.na(.)))

linreg <- glm(TP ~ ., data = watertrain2)

summary(linreg)

tidy(linreg) %>% 
  filter(p.value < 0.05) %>%
  mutate(estimate = round(estimate, digits = 3),
         p.value = round(p.value, digits = 3)) %>%
  select(term, estimate, p.value) %>%
  kbl(booktabs = T)

tidy(linreg) %>% 
  filter(p.value >= 0.05) %>%
  mutate(estimate = round(estimate, digits = 3),
         p.value = round(p.value, digits = 3)) %>%
  select(term, estimate, p.value) %>%
  kbl(booktabs = T)

# watertrain2.selected <- fullTP[train_idx[,2],] %>%
#   select(all_of(c("TEMP", "DO", "TURB", "COND", "FLDNUM", 
#                   "CHLcal", "quarter"))) %>%
#   filter_all(all_vars(!is.na(.))) 
# TODO remove the missing values here and try to run the regression again, see if it applies to more values

```

```{r}
sum(fitted(linreg) == predict(linreg))
```


```{r}
watertrain2$TP.PREDICT <- predict(linreg)

watertrain2 <- watertrain2 %>%
  mutate(TP.SQ.ERROR = (TP - TP.PREDICT)^2)

print("RSME is")
sqrt(sum(watertrain2$TP.SQ.ERROR)/dim(watertrain2)[1])

watertrain2 %>% 
  ggplot(aes(x = TP, y = TP.PREDICT)) +
  geom_point(alpha = 0.2) +
  coord_equal() +
  theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)

ggsave("glm_train_predictvsactual.png")

```


```{r}

watertest2$TP.PREDICT <- predict(linreg, watertest2)
  
watertest2 <- watertest2 %>%
  mutate(TP.SQ.ERROR = (TP - TP.PREDICT)^2)

print("RSME is")
sqrt(sum(watertest2$TP.SQ.ERROR)/dim(watertest2)[1])

watertest2 %>% 
  ggplot(aes(x = TP, y = TP.PREDICT)) +
  geom_point(alpha = 0.2) +
  coord_equal() +
  theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)

ggsave("glm_test_predictvsactual.png")

```



### TP by year and season

```{r, eval = F}

make_year_touples <- function(index, year_partition){
  # index goes from 1 to length(year_partition) - 1
  
  return(c(year_partition[index], year_partition[index+1]))
  
}

tree_by_years <- function(year_touple, water_data){
  
  # filter for specific group of years
  water_data <- water_data %>% filter(year >= year_touple[1] &
                                        year <= year_touple[2])
  
  fitControl <- caret::trainControl(method="cv")

  tr.TP <- caret::train(TP ~ ., 
                        data = water_data,
                        # what is method?
                        method = "rpart2", 
                        trControl = fitControl, 
                        # don't quite understand maxdepth
                        tuneGrid = data.frame(maxdepth=1:20))
  
  return(tr.TP)
  
}

tree_by_season <- function(season, min_year, max_year, year_interval, water_data){
  # season can be 1, 2, 3, 4 with 1 being spring
  ## this is already processed in line 70
  
  year_partition <- seq(min_year, max_year, year_interval)
  # make a list of each year interval
  year_touples <- lapply(1:(length(year_partition)-1), make_year_touples, year_partition)
  
  water_data <- water_data %>% filter(quarter == season)
  
  tree_models <- lapply(year_touples, tree_by_years, water_data)
  
  return(tree_models)
  
}

```

\newpage

#### TP spring

```{r, eval = F}
 

# model for spring, 2000-2005, ..., 2015-2020
trees.sp.2000.2020 <- tree_by_season(1, # 1 stands for spring
                                     2000, # minimum year
                                     2020, # maximum year
                                     5, # 5 year intervals
                                     narm_water20) # dataset

# the 4 comes from (2020 - 2000) / 5
lapply(1:4, function(x) return(fancyRpartPlot(trees.sp.2000.2020[[x]]$finalModel,
                                              main = paste(as.character(x)) )))

lapply(1:4, function(x) return(plot(trees.sp.2000.2020[[x]], 
                                    main = paste(as.character(x)) )))


```
\newpage

#### TP summer

```{r, eval = F}

# model for summer, 2000-2020
trees.su.2000.2020 <- tree_by_season(2, 2000, 2020, 5, narm_water20)

# the 4 comes from (2020 - 2000) / 5
lapply(1:4, function(x) return(fancyRpartPlot(trees.su.2000.2020[[x]]$finalModel,
                                              main = paste(as.character(x)) )))

lapply(1:4, function(x) return(plot(trees.su.2000.2020[[x]], 
                                    main = paste(as.character(x)) )))

```

\newpage

#### TP fall

```{r, eval = F}

# model for fall, 2000-2020
trees.fa.2000.2020 <- tree_by_season(3, 2000, 2020, 5, narm_water20)

# the *2 is to insert line breaks
lapply(1:4*2, function(x)
  if (x %% 2 == 1) { # if x is even
    asis_output("\\\\[10cm]")
    } else {
      return(fancyRpartPlot(trees.fa.2000.2020[[x/2]]$finalModel,
                            main = paste(as.character(x/2)) ))
    } )

lapply(1:4, function(x) return(plot(trees.fa.2000.2020[[x]],
                                    main = paste(as.character(x)) )))

```

\newpage 

#### TP winter

```{r, eval = F}

# model for winter, 2000-2020
trees.wi.2000.2020 <- tree_by_season(4, 2000, 2020, 5, narm_water20)

lapply(1:4, function(x) return(fancyRpartPlot(trees.wi.2000.2020[[x]]$finalModel,
                                              main = paste(as.character(x)) )))

lapply(1:4, function(x) return(plot(trees.wi.2000.2020[[x]], 
                                    main = paste(as.character(x)) )))

```

