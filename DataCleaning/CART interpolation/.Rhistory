train_idx <- createDataPartition(water20$TP, p = .8,
list = FALSE, times = 1,
na.rm = TRUE)
fullTP <- water20 %>% filter(!is.na(TP))
# train and test data
train_idx <- createDataPartition(fullTP$TP, p = .8,
list = FALSE, times = 1)
# train and test data
train_idx <- createDataPartition(fullTP$TP, p = .8,
list = FALSE, times = 2)
# train and test data
train_idx <- createDataPartition(fullTP$TP, p = .8,
list = FALSE, times = 10)
watertrain1 <- water20[train_idx[1],]
watertest1 <- water20[-train_idx[1],]
watertrain1 <- fullTP[train_idx[1],]
watertest1 <- fullTP[-train_idx[1],]
watertest1 <- fullTP[(-train_idx[1]),]
train_idx
train_idx[[1]]
train_idx[1]
train_idx
train_idx$Resample01
train_idx[Resample01]
[Resample01]
names(train_idx)
typeof(train_idx)
train_idx[1,]
watertrain1 <- fullTP[train_idx[,1],]
watertest1 <- fullTP[-train_idx[,1],]
tr.TP <- rpart(TP ~ .,
data = watertrain1)
tr.TP
?rpart
water20 <- read.csv("cleaned_data.csv", header = TRUE)
water20 <- water20 %>%
mutate(nice_date = mdy(DATE),
year = year(nice_date),
quarter = quarter(nice_date, fiscal_start = 3),
FLDNUM = case_when(FLDNUM == 1 ~ "Lake City, MN",
FLDNUM == 2 ~ "Onalaska, WI",
FLDNUM == 3 ~ "Bellevue, IA",
FLDNUM == 4 ~ "Brighton, IL",
FLDNUM == 5 ~ "Jackson, MO",
FLDNUM == 6 ~ "Havana, IL")) %>%
select(-SHEETBAR, -nice_date, -DATE, -LOCATCD)
# train and test data created from rows with existing TP values
fullTP <- water20 %>% filter(!is.na(TP))
# this gives me a total of ten 80/20 splits
train_idx <- createDataPartition(fullTP$TP, p = .8,
list = FALSE, times = 10)
watertrain1 <- fullTP[train_idx[,1],]
watertest1 <- fullTP[-train_idx[,1],]
watertrain1
# remove the QF code var
water_var <- names(water20)[str_detect(names(water20), "QF", negate = T)]
water20 <- water20 %>% select(all_of(water_var))
# train and test data created from rows with existing TP values
fullTP <- water20 %>% filter(!is.na(TP))
# this gives me a total of ten 80/20 splits
train_idx <- createDataPartition(fullTP$TP, p = .8,
list = FALSE, times = 10)
watertrain1 <- fullTP[train_idx[,1],]
watertest1 <- fullTP[-train_idx[,1],]
watertrain1
tr.TP <- rpart(TP ~ .,
data = watertrain1)
fancyRpartPlot(tr.TP$finalModel)
fancyRpartPlot(tr.TP)
tr.TP
water20 <- water20 %>% mutate(FLDNUM = as.factor(FLDNUM))
# train and test data created from rows with existing TP values
fullTP <- water20 %>% filter(!is.na(TP))
# this gives me a total of ten 80/20 splits
train_idx <- createDataPartition(fullTP$TP, p = .8,
list = FALSE, times = 10)
watertrain1 <- fullTP[train_idx[,1],]
watertest1 <- fullTP[-train_idx[,1],]
tr.TP <- rpart(TP ~ .,
data = watertrain1,
control = rpart.control(cp = 0.0001))
print(tr.TP)
fancyRpartPlot(tr.TP)
tr.TP <- rpart(TP ~ .,
data = watertrain1,
control = rpart.control(minsplit = 100, # 1% of data
maxcompete = 3,
maxsurrogate = 5,
usesurrogate = 2,
xval = 10,
surrogatestyle = 0,
cp = 0.01))
print(tr.TP)
fancyRpartPlot(tr.TP)
tr.TP <- rpart(TP ~ .,
data = watertrain1,
control = rpart.control(xval = 10))
print(tr.TP)
printcp(tr.TP)
fancyRpartPlot(tr.TP)
printcp(tr.TP)
tr.TP$cptable
tr.TP <- rpart(TP ~ .,
data = watertrain1,
control = rpart.control(xval = 20))
printcp(tr.TP)
tr.TP$cptable
tr.TP <- rpart(TP ~ .,
data = watertrain1,
control = rpart.control(xval = 10,
minsplit = 100))
printcp(tr.TP)
fancyRpartPlot(tr.TP)
View(water20)
tr.TP$cptable
bestcp <- tr.TP$cptable[which.min(tr.TP$cptable[,"xerror"]),"CP"]
bestcp
tr.TP$cptable
printcp(tr.TP)
fancyRpartPlot(tr.TP)
tr.TP$cptable[tr.TP$CP == .01]
tr.TP$cptable[tr.TP$cptable$CP == .01]
typeof(tr.TP)
bind_rows(tr.TP)
rbind(tr.TP)
cbind(tr.TP)
bind_cols(tr.TP)
data.frame(tr.TP)
as.data.frame(tr.TP)
View(tr.TP)
tr.TP$frame
bind_rows(tr.TP$cptable)
bind_cols(tr.TP$cptable)
bind_cols(tr.TP$cptable)
bind_cols(tr.TP$cptable)
data.frame(bind_cols(tr.TP$cptable))
data.frame(bind_cols(tr.TP$cptable))
bestcp
# Prediction error rate in training data = Root node error * rel error * 100%
# Prediction error rate in cross-validation = Root node error * xerror * 100%
# Hence we want the cp value (with a simpler tree) that minimizes the xerror.
# Root node error is 0.034974
data.frame(bind_cols(tr.TP$cptable))
bestcp <- tr.TP$cptable[which.min(tr.TP$cptable[,"xerror"]),"CP"]
print(data.frame(bind_cols(tr.TP$cptable)))
tr.TP <- prune(tr.TP, cp = bestcp)
tr.TP
printcp(tr.TP)
?predict
predict(tr.TP)
table(watertrain$TP, predict(tr.TP))
watertrain1
table(watertrain1$TP, predict(tr.TP))
summary(tr.TP)
fancyRpartPlot(tr.TP)
plotcp(tr.TP)
rsq.rpart(tr.TP)
bestcp <- tr.TP$cptable[which.min(tr.TP$cptable[,"xerror"]),"CP"]
bestcp
printcp(tr.TP)
plotcp(tr.TP)
printcp(tr.TP)
summary(tr.TP)
fancyRpartPlot(tr.TP)
plotcp(tr.TP)
printcp(tr.TP)
fancyRpartPlot(tr.TP)
plotcp(tr.TP)
0.034974*0.54427
summary(tr.TP)
tr.TP <- rpart(TP ~ .,
data = watertrain1,
control = rpart.control(xval = 10,
minsplit = 100))
printcp(tr.TP)
fancyRpartPlot(tr.TP)
plotcp(tr.TP)
predict(tr.TP, data = watertrain1)
plot(x = watertrain1$TN,
y = predict(tr.TP, data = watertrain1))
watertrain1$TN
min(watertrain1$TN)
watertrain1$TN
predict(tr.TP, data = watertrain1)
plot(x = watertrain1$TP,
y = predict(tr.TP, data = watertrain1))
watertrain1$TP
max(watertrain1$TN)
max(watertrain1$TN, na.rm = TRUE)
min(watertrain1$TN, na.rm = TRUE)
watertrain1$PREDICT <- predict(tr.TP, data = watertrain1)
watertrain1
watertrain1$TP.PREDICT <- predict(tr.TP, data = watertrain1)
watertrain1 %>% select(TP, TP.PREDICT)
plot(x = watertrain1$TP,
y = watertrain1$TP.PREDICT)
plot(x = watertrain1$TP,
y = watertrain1$TP.PREDICT,
xlim = c(0, 2),
ylim = c(0, 2))
watertrain1 <- watertrain1 %>%
mutate(TP.SQ.ERROR = (TP - TP.PREDICT)^2)
sqrt(sum(watertrain1$TP.SQ.ERROR)/dim(watertrain)[1])
sqrt(sum(watertrain1$TP.SQ.ERROR)/dim(watertrain1)[1])
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT))
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point()
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point() +
coord_equal()
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point() +
coord_equal() +
theme(aspect.ratio = 1)
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point() +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point(aes(fill = TP.SQ.ERROR)) +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point(alpha = 0.5) +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point(alpha = 0.15) +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point(alpha = 0.2) +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point() +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 7) + ylim(0, 7)
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point(alpha = 0.2) +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
plot(TP.PREDICT ~ TP, data = watertrain1)
plot(TP.PREDICT ~ TP, data = watertrain1)
glm(TP.PREDICT ~ TP, data = watertrain1)
watertest1$TP.PREDICT <- predict(tr.TP = data = watertest1)
watertest1$TP.PREDICT <- predict(tr.TP, data = watertest1)
TP.PREDICT <- predict(tr.TP, data = watertest1)
TP.PREDICT
dim(TP.PREDICT)
length(TP.PREDICT)
dim(water20 %>% filter(TP > 2))
water20 <- water20 %>%
filter(TP <= 2) %>% # only 70 samples for TP > 2, outlier values screw up model
mutate(nice_date = mdy(DATE),
year = year(nice_date),
quarter = quarter(nice_date, fiscal_start = 3),
FLDNUM = case_when(FLDNUM == 1 ~ "Lake City, MN",
FLDNUM == 2 ~ "Onalaska, WI",
FLDNUM == 3 ~ "Bellevue, IA",
FLDNUM == 4 ~ "Brighton, IL",
FLDNUM == 5 ~ "Jackson, MO",
FLDNUM == 6 ~ "Havana, IL"),
FLDNUM = as.factor(FLDNUM)) %>% # CART can split on categorical variable if
# encoded as a factor variable
select(-SHEETBAR, -nice_date, -DATE, -LOCATCD)
water20 <- read.csv("cleaned_data.csv", header = TRUE)
# remove the QF code var
water_var <- names(water20)[str_detect(names(water20), "QF", negate = T)]
water20 <- water20 %>% select(all_of(water_var))
var_missing_rate %>% filter(missing_rate > 0) %>%
ggplot(aes(x = var, y = missing_rate)) +
geom_bar(stat = "identity") +
coord_flip()
water20 <- water20 %>%
filter(TP <= 2) %>% # only 70 samples for TP > 2, outlier values screw up model
mutate(nice_date = mdy(DATE),
year = year(nice_date),
quarter = quarter(nice_date, fiscal_start = 3),
FLDNUM = case_when(FLDNUM == 1 ~ "Lake City, MN",
FLDNUM == 2 ~ "Onalaska, WI",
FLDNUM == 3 ~ "Bellevue, IA",
FLDNUM == 4 ~ "Brighton, IL",
FLDNUM == 5 ~ "Jackson, MO",
FLDNUM == 6 ~ "Havana, IL"),
FLDNUM = as.factor(FLDNUM)) %>% # CART can split on categorical variable if
# encoded as a factor variable
select(-SHEETBAR, -nice_date, -DATE, -LOCATCD)
set.seed(4747)
options(expressions = 5e5)
# train and test data created from rows with existing TP values
fullTP <- water20 %>% filter(!is.na(TP))
# this gives me a total of ten 80/20 splits
train_idx <- createDataPartition(fullTP$TP, p = .8,
list = FALSE, times = 10)
watertrain1 <- fullTP[train_idx[,1],]
watertest1 <- fullTP[-train_idx[,1],]
tr.TP <- rpart(TP ~ .,
data = watertrain1,
control = rpart.control(xval = 10,
minsplit = 100))
printcp(tr.TP)
fancyRpartPlot(tr.TP)
plotcp(tr.TP)
summary(tr.TP)
bestcp <- tr.TP$cptable[which.min(tr.TP$cptable[,"xerror"]),"CP"]
# Prediction error rate in training data = Root node error * rel error * 100%
# Prediction error rate in cross-validation = Root node error * xerror * 100%
# Hence we want the cp value (with a simpler tree) that minimizes the xerror.
#
bestcp <- tr.TP$cptable[which.min(tr.TP$cptable[,"xerror"]),"CP"]
bestcp
tr.TP.prune <- prune(tr.TP, cp = bestcp)
printcp(tr.TP.prune)
plotcp(tr.TP.prune)
bestcp
watertrain1$TP.PREDICT <- predict(tr.TP, data = watertrain1)
watertrain1 <- watertrain1 %>%
mutate(TP.SQ.ERROR = (TP - TP.PREDICT)^2)
print("RSME is")
sqrt(sum(watertrain1$TP.SQ.ERROR)/dim(watertrain1)[1])
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point() +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 7) + ylim(0, 7)
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point(alpha = 0.2) +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point(alpha = 0.2, jitter = TRUE) +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
print("RSME is")
sqrt(sum(watertrain1$TP.SQ.ERROR)/dim(watertrain1)[1])
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point(alpha = 0.2) +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
70/59241
predict(tr.TP, data = watertest1)
histogram(TP.PREDICT)
print("RSME is")
sqrt(sum(watertrain1$TP.SQ.ERROR)/dim(watertrain1)[1])
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point(alpha = 0.2) +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
watertrain2 <- fullTP[train_idx[,2],]
watertest2 <- fullTP[-train_idx[,2],]
glm(TP ~ ., data = watertrain2)
summary(glm(TP ~ ., data = watertrain2))
?glm
linreg.TP <- glm(TP ~ ., data = watertrain2))
linreg.TP <- glm(TP ~ ., data = watertrain2)
watertrain2$TP.PREDICT <- predict(linreg.TP, data = watertrain2)
watertrain2
dim(watertrain2)
predict(linreg.TP, data = watertrain2)
dim(watertrain2)
dim(watertest2)
length(predict(predict(linreg.TP, data = watertrain2)))
predict(tr.TP, data = watertrain1)
?print
?predict
predict.glm(linreg.TP, data = watertrain2)))
predict.glm(linreg.TP, data = watertrain2))
predict.glm(linreg.TP, data = watertrain2)
length(predict.glm(linreg.TP, data = watertrain2))
dim(watertrain2)
dim(watertest2)
length(predict.glm(linreg.TP, data = watertrain2))
length(predict.glm(linreg.TP))
plot(predict.glm(linreg.TP))
length(predict.glm(linreg.TP, type = "response"))
dim(watertrain2)
dim(watertest2)
length(predict.glm(linreg.TP, type = "response"))
fitted()linreg.TP
fitted(linreg.TP)
linreg.TP <- lm(TP ~ ., data = watertrain2)
linreg.TP
summary(linreg.TP)
linreg.TP <- glm(TP ~ ., data = watertrain2)
watertrain1$TP.PREDICT.TEST <- predict(tr.TP, data = watertest1)
library(tidyverse)
library(stringr)
library(lubridate)
library(rpart) # for regression tree
library(rpart.plot)
library(rattle)
library(kableExtra)
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
water20 <- read.csv("cleaned_data.csv", header = TRUE)
water20 %>% select(all_of(str_detect(names(water20),
"QF", negate = T)))
water20 %>% select(all_of(names(water20)
[str_detect(names(water20),
"QF", negate = T)]))
water20 <- water20 %>% select(all_of(names(water20)
[str_detect(names(water20),
"QF", negate = T)]))
var_missing_rate <- sapply(water20, function(x) sum(is.na(x))/length(x))
var_missing_rate <- data.frame(var = names(var_missing_rate),
missing_rate = unname(var_missing_rate))
var_missing_rate %>%
mutate(`missing rate` = round(missing_rate, digits = 3)) %>%
select(-missing_rate) %>%
arrange(-`missing rate`) %>%
kbl(booktabs = T)
var_missing_rate %>% filter(missing_rate > 0) %>%
ggplot(aes(x = var, y = missing_rate)) +
geom_bar(stat = "identity") +
coord_flip()
water20 <- water20 %>%
filter(TP <= 2) %>% # only 70 samples for TP > 2, outlier values screw up model
mutate(nice_date = mdy(DATE),
year = year(nice_date),
quarter = quarter(nice_date, fiscal_start = 3),
FLDNUM = case_when(FLDNUM == 1 ~ "Lake City, MN",
FLDNUM == 2 ~ "Onalaska, WI",
FLDNUM == 3 ~ "Bellevue, IA",
FLDNUM == 4 ~ "Brighton, IL",
FLDNUM == 5 ~ "Jackson, MO",
FLDNUM == 6 ~ "Havana, IL"),
FLDNUM = as.factor(FLDNUM)) %>% # CART can split on categorical variable if
# encoded as a factor variable
select(-SHEETBAR, -nice_date, -DATE, -LOCATCD)
set.seed(4747)
options(expressions = 5e5)
# train and test data created from rows with existing TP values
fullTP <- water20 %>% filter(!is.na(TP))
# this gives me a total of ten 80/20 splits
train_idx <- createDataPartition(fullTP$TP, p = .8,
list = FALSE, times = 10)
library(caret) # for other models
set.seed(4747)
# train and test data created from rows with existing TP values
fullTP <- water20 %>% filter(!is.na(TP))
# this gives me a total of ten 80/20 splits
train_idx <- createDataPartition(fullTP$TP, p = .8,
list = FALSE, times = 10)
watertrain1 <- fullTP[train_idx[,1],]
watertest1 <- fullTP[-train_idx[,1],]
tr.TP <- rpart(TP ~ .,
data = watertrain1,
control = rpart.control(xval = 10,
minsplit = 100))
printcp(tr.TP)
fancyRpartPlot(tr.TP)
plotcp(tr.TP)
summary(tr.TP)
bestcp <- tr.TP$cptable[which.min(tr.TP$cptable[,"xerror"]),"CP"]
bestcp
tr.TP.prune <- prune(tr.TP, cp = bestcp)
watertrain1$TP.PREDICT <- predict(tr.TP, data = watertrain1)
watertrain1 <- watertrain1 %>%
mutate(TP.SQ.ERROR = (TP - TP.PREDICT)^2)
print("RSME is")
sqrt(sum(watertrain1$TP.SQ.ERROR)/dim(watertrain1)[1])
watertrain1 %>%
ggplot(aes(x = TP, y = TP.PREDICT)) +
geom_point(alpha = 0.2) +
coord_equal() +
theme(aspect.ratio = 1) + xlim(0, 2) + ylim(0, 2)
watertrain2 <- fullTP[train_idx[,2],]
watertest2 <- fullTP[-train_idx[,2],]
linreg.TP <- glm(TP ~ ., data = watertrain2)
summary(linreg.TP)
dim(watertrain2)
dim(watertest2)
linreg <- glm(TP ~ ., data = watertrain2)
rm(linreg.TP)
linreg
summary(linreg)
typeof(linreg)
?caret
linreg <- caret::train(TP ~ .,
data = watertrain2,
method=" method = 'BstLm'")
watertrain2[is.na(watertrain2$TP)]
linreg <- caret::train(TP ~ .,
data = (watertrain2 %>% filter(!is.na(.))),
method=" method = 'BstLm'")
linreg <- caret::train(TP ~ .,
data = (watertrain2 %>%
filter_all(any_vars(is.na(.)))),
method=" method = 'BstLm'")
watertrain2 %>%
filter_all(any_vars(is.na(.)))
watertrain2 %>%
filter_all(!any_vars(is.na(.)))
linreg <- caret::train(TP ~ .,
data = (watertrain2 %>%
filter_all(any_vars(!is.na(.)))),
method=" method = 'BstLm'")
